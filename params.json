{"name":"Cplus3","tagline":"cplus analysis about virtual function.","body":"`关于c++虚函数的解析:`\r\n\r\n   虚函数给予了c++很强大的特性[多态],那么虚函数在对象中的内存分布又是如何的恩?是如何做多动态的多态的恩?\r\n下面会一一解答这些问题[个人所见,如有错误,欢迎拍砖].\r\n\r\n  看看如下代码:\r\n  \r\n\r\n```c  \r\nusing namespace std;\r\n#include<iostream>\r\n\r\n\r\nclass A {\r\npublic:\r\n   virtual void print() {\r\n        cout<<\"A\"<<endl;\r\n   }\r\nprivate:\r\n   //int a;\r\n};\r\n\r\n\r\n//class B : public virtual A {\r\nclass B : public  A {\r\npublic:\r\n   virtual void print() {\r\n        cout<<\"B\"<<endl;\r\n   }\r\n   virtual void printf() {\r\n        cout<<\"Bf\"<<endl;\r\n   }\r\nprivate:\r\n \r\n};\r\n\r\n\r\ntypedef void (*Pfun)();\r\n\r\nint main()\r\n{\r\n    A a;\r\n    B b;\r\n    Pfun fun;\r\n    int i = 0;\r\n\r\n    for(; i < 2; i++)\r\n    {\r\n         fun = (Pfun) *((int*)*(int*)(&b)+i);\r\n         fun();\r\n\r\n    }\r\n    return 0;\r\n\r\n}\r\n```\r\n\r\n输出结果:      \r\n```\r\nB\r\nBf\r\n```  \r\n问题一之虚表指针存放与何处:\r\n===\r\ngdb调试看到如下:\r\n```\r\n(gdb) p a\r\n$1 = {_vptr.A = 0x400c70 <vtable for A+16>}\r\n(gdb) p b\r\n$2 = warning: can't find linker symbol for virtual table for `B' value\r\nwarning:   found `B::B()' instead\r\n{<A> = {_vptr.A = 0x400ba0 <__libc_csu_init>}, <No data fields>}\r\n```\r\n每个对象都有一个vptr指针---虚表指针(用来存放虚函数的地址).     \r\n注意:虚表指针位于一个对象的首的前四字节[32位系统].为啥要在放在对象首部恩? 原因很简单,便于后续的查询速度呗.      \r\n\r\n问题二之输出结果为啥是这样:\r\n====\r\n* 1.&b 是对象b的地址    \r\n* 2.(int*)(&b) 把b的地址强转为int*,这样便于后面往出取值的时候按照int的方式取.    \r\n* 3.*(int*)(&b) 按照int的解析方式,取出对象b地址中的前4字节---虚表指针首地址.    \r\n* 4.(int*)*(int*)(&b)+i 表示指向虚表指针的偏移量为i的位置.[此处可以把虚表指针理解为一个指针数组,其中数组中\r\n存放的是虚函数的地址].       \r\n* 5.(Pfun*)((int*)(*(int*)(&b)+i) 把这个int型指针强转为Pfun类型的函数指针.       \r\n* 6.fun() 调用这个虚函数.        \r\n\r\n问题三之虚表指针何时共享与否:    \r\n======\r\n *  1.当非虚拟继承的时候,此时不管子类是否有新的虚函数,此时父子的虚表是共享的.[单继承情况下].    \r\n * 2.当虚拟继承的时候.如子类出现了新的虚函数,则父与子此时不在共享虚表指针,此时子对象会产生\r\n  一个新的虚表指针存放新的虚函数.     \r\n\r\n问题四之多继承的时候子类的虚表是怎么样的:\r\n=====\r\n   当子类D多继承与类A B C的时候,其中ABC中都有虚函数:     \r\n     \r\n * 1.当D中发生虚函数覆盖的时候[如D中重写了A中的某一个虚函数],此时A与D是共享虚表的,然后在D中还有另外两个\r\n     虚表存储B和C.    \r\n * 2.当D中没有发生虚函数覆盖的时候,此时在D中会有4个虚表指针.       \r\n\r\n\r\n\r\n\r\n\r\n\r\nCommunite  \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/fakangwang)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n","google":"cplus analysis about virtual function.","note":"Don't delete this file! It's used internally to help with page regeneration."}